/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MainPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian8 = require("obsidian");

// src/FileTablePlugin.ts
var import_obsidian7 = require("obsidian");

// src/services/FileService.ts
var import_obsidian = require("obsidian");

// src/services/MetadataService.ts
var MetadataService = class {
  constructor(vault) {
    this.vault = vault;
  }
  async getFileInfo(file) {
    const stat = await this.vault.adapter.stat(file.path);
    if (!stat) {
      throw new Error(`Unable to get stats for file: ${file.path}`);
    }
    return {
      name: file.name,
      extension: file.extension,
      createdAt: new Date(stat.ctime),
      modifiedAt: new Date(stat.mtime),
      size: stat.size,
      path: file.path,
      icon: this.getIconForFileType(file.extension),
      folder: this.getFolderPath(file.path)
      // Добавляем путь к папке
    };
  }
  getIconForFileType(extension) {
    const iconMap = {
      pdf: "file-pdf",
      doc: "file-word",
      docx: "file-word",
      xls: "file-excel",
      xlsx: "file-excel",
      ppt: "file-powerpoint",
      pptx: "file-powerpoint",
      jpg: "file-image",
      jpeg: "file-image",
      png: "file-image",
      gif: "file-image",
      mp3: "file-audio",
      wav: "file-audio",
      mp4: "file-video",
      avi: "file-video",
      zip: "file-archive",
      rar: "file-archive"
      // Добавьте другие расширения и соответствующие им иконки
    };
    return iconMap[extension.toLowerCase()] || "file";
  }
  getFolderPath(filePath) {
    const parts = filePath.split("/");
    parts.pop();
    return parts.join("/") || "/";
  }
};

// src/services/FileService.ts
var FileService = class {
  constructor(vault, app) {
    this.vault = vault;
    this.app = app;
    this.metadataService = new MetadataService(vault);
  }
  async getFilesInFolder(folderPath, extensions) {
    const files = this.vault.getFiles().filter((file) => {
      const isInFolder = folderPath === "" || file.path.startsWith(folderPath);
      const hasCorrectExtension = extensions.includes(file.extension);
      return isInFolder && hasCorrectExtension;
    });
    const uniqueFiles = /* @__PURE__ */ new Map();
    files.forEach((file) => {
      if (!uniqueFiles.has(file.path)) {
        uniqueFiles.set(file.path, file);
      }
    });
    const fileInfoPromises = Array.from(uniqueFiles.values()).map((file) => this.metadataService.getFileInfo(file));
    return Promise.all(fileInfoPromises);
  }
  openFile(path) {
    const file = this.vault.getAbstractFileByPath(path);
    if (file instanceof import_obsidian.TFile) {
      const extension = file.extension.toLowerCase();
      const isImageOrPdf = ["png", "jpg", "jpeg", "gif", "bmp", "svg", "pdf"].includes(extension);
      let leaf;
      if (isImageOrPdf) {
        leaf = this.app.workspace.getLeaf("tab");
      } else {
        leaf = this.getLeaf();
      }
      leaf.openFile(file, { active: true });
    }
  }
  getLeaf() {
    const leaf = this.app.workspace.getMostRecentLeaf();
    if (leaf && !leaf.getViewState().pinned) {
      return leaf;
    }
    return this.app.workspace.getLeaf("tab");
  }
};

// src/services/FolderService.ts
var import_obsidian2 = require("obsidian");
var FolderService = class {
  constructor(vault) {
    this.vault = vault;
  }
  getFolders() {
    const folders = [{ name: "\u041A\u043E\u0440\u043D\u0435\u0432\u0430\u044F \u043F\u0430\u043F\u043A\u0430", path: "" }];
    this.traverseFolders(this.vault.getRoot(), folders);
    return folders;
  }
  traverseFolders(folder, result) {
    folder.children.forEach((child) => {
      if (child instanceof import_obsidian2.TFolder) {
        result.push({ name: child.name, path: child.path });
        this.traverseFolders(child, result);
      }
    });
  }
  // ... остальной код ...
};

// src/ui/FileTable.ts
var import_obsidian3 = require("obsidian");
var FileTable = class extends import_obsidian3.Component {
  constructor(containerEl, onFileOpen) {
    super();
    this.containerEl = containerEl;
    this.onFileOpen = onFileOpen;
    this.files = [];
    this.filteredFiles = [];
    this.groupByFolder = false;
    this.sortColumn = "name";
    this.sortDirection = "asc";
    this.filters = {};
    this.filterInputs = /* @__PURE__ */ new Map();
    this.currentFolder = "";
    this.allFolders = [];
    this.folderHistory = [];
    this.render();
  }
  setFiles(files) {
    console.log("Setting files:", files);
    this.files = files;
    this.updateFolderDropdown();
    this.applyFiltersAndSort();
    this.renderBody();
  }
  setGroupByFolder(groupByFolder) {
    this.groupByFolder = groupByFolder;
    this.applyFiltersAndSort();
    this.renderBody();
  }
  setFolderFilter(folder) {
    if (folder !== this.currentFolder) {
      this.folderHistory.push(this.currentFolder);
      this.currentFolder = folder;
      this.applyFiltersAndSort();
      this.renderBody();
      this.updateFolderDropdown();
    }
  }
  render() {
    this.containerEl.empty();
    this.containerEl.addClass("file-table-container");
    const controlsEl = this.containerEl.createDiv({ cls: "file-table-controls" });
    this.renderBackButton(controlsEl);
    this.renderFolderDropdown(controlsEl);
    const tableWrapper = this.containerEl.createEl("div", { cls: "file-table-wrapper" });
    const table = tableWrapper.createEl("table", { cls: "file-table" });
    this.renderHeader(table);
    this.renderBody(table);
  }
  renderBackButton(containerEl) {
    this.backButton = new import_obsidian3.ButtonComponent(containerEl).setButtonText("\u041D\u0430\u0437\u0430\u0434").onClick(() => this.goBack()).setDisabled(true);
  }
  renderFolderDropdown(containerEl) {
    const folderSelectEl = containerEl.createDiv({ cls: "folder-select" });
    folderSelectEl.createSpan({ text: "\u041F\u0430\u043F\u043A\u0430: " });
    this.folderFilter = new import_obsidian3.TextComponent(folderSelectEl).setPlaceholder("\u0424\u0438\u043B\u044C\u0442\u0440 \u043F\u0430\u043F\u043E\u043A").onChange(this.updateFolderDropdown.bind(this));
    this.folderDropdown = new import_obsidian3.DropdownComponent(folderSelectEl);
    this.folderDropdown.onChange((value) => {
      this.setFolderFilter(value);
    });
    this.updateFolderDropdown();
  }
  updateFolderDropdown() {
    const folders = new Set([""].concat(this.files.map((file) => file.folder)));
    this.allFolders = Array.from(folders).sort();
    const filterValue = this.folderFilter.getValue().toLowerCase();
    const filteredFolders = this.allFolders.filter(
      (folder) => folder.toLowerCase().includes(filterValue)
    );
    this.folderDropdown.selectEl.empty();
    this.folderDropdown.addOption("", "\u0412\u0441\u0435 \u043F\u0430\u043F\u043A\u0438");
    filteredFolders.forEach((folder) => {
      if (folder !== "") {
        this.folderDropdown.addOption(folder, folder);
      }
    });
    this.folderDropdown.setValue(this.currentFolder);
    this.backButton.setDisabled(this.folderHistory.length === 0);
  }
  renderHeader(table) {
    const thead = table.createTHead();
    const row = thead.insertRow();
    const columns = ["name", "extension", "folder", "createdAt", "modifiedAt", "size"];
    columns.forEach((column) => {
      const th = row.createEl("th");
      const button = th.createEl("button");
      button.textContent = this.capitalizeFirstLetter(column);
      button.addEventListener("click", () => this.sortBy(column));
      const input = th.createEl("input", { type: "text" });
      input.placeholder = `Filter ${column}`;
      input.addEventListener("input", (event) => this.setFilter(column, event.target.value));
    });
  }
  renderBody(table) {
    if (!table) {
      const foundTable = this.containerEl.querySelector("table");
      if (foundTable instanceof HTMLTableElement) {
        table = foundTable;
      } else {
        console.error("Table element not found");
        return;
      }
    }
    const oldBody = table.tBodies[0];
    const newBody = document.createElement("tbody");
    const groupedFiles = this.groupByFolder ? this.groupFilesByFolder(this.filteredFiles) : { "\u0412\u0441\u0435 \u0444\u0430\u0439\u043B\u044B": this.filteredFiles };
    Object.entries(groupedFiles).forEach(([folder, files]) => {
      if (this.currentFolder === "" || folder === this.currentFolder) {
        if (this.groupByFolder || folder === "\u0412\u0441\u0435 \u0444\u0430\u0439\u043B\u044B") {
          const folderRow = newBody.insertRow();
          const folderCell = folderRow.createEl("td", { attr: { colspan: "6" }, cls: "folder-header" });
          if (folder === "\u041A\u043E\u0440\u043D\u0435\u0432\u0430\u044F \u043F\u0430\u043F\u043A\u0430" || folder === "\u0412\u0441\u0435 \u0444\u0430\u0439\u043B\u044B") {
            folderCell.textContent = folder;
          } else {
            const folderName = folder.split("/").pop() || folder;
            folderCell.createSpan({ text: folderName, cls: "folder-name" });
            folderCell.createSpan({ text: ` (${folder})`, cls: "folder-path" });
          }
        }
        files.forEach((file) => {
          const row = newBody.insertRow();
          const columns = ["name", "extension", "folder", "createdAt", "modifiedAt", "size"];
          columns.forEach((key) => {
            const cell = row.insertCell();
            const value = file[key];
            if (key === "name") {
              const iconSpan = cell.createSpan({ cls: "file-icon" });
              (0, import_obsidian3.setIcon)(iconSpan, file.icon);
              cell.createSpan({ text: value.toString() });
              cell.classList.add("file-name");
              cell.addEventListener("click", (event) => {
                event.preventDefault();
                event.stopPropagation();
                this.onFileOpen(file.path);
              });
            } else if (key === "size") {
              cell.textContent = this.formatFileSize(value);
            } else if (key === "folder") {
              const folderLink = cell.createEl("a", {
                text: value.toString(),
                cls: "file-folder-link",
                attr: { href: "#", title: "\u041E\u0442\u043A\u0440\u044B\u0442\u044C \u043F\u0430\u043F\u043A\u0443" }
              });
              folderLink.addEventListener("click", (event) => {
                event.preventDefault();
                event.stopPropagation();
                this.openFolder(value.toString());
                this.removeAllTooltips();
              });
              cell.classList.add("file-folder");
              this.addFolderPreviewHandler(folderLink, this.getFilesInFolder(value.toString()));
            } else {
              cell.textContent = value instanceof Date ? value.toLocaleString() : value.toString();
            }
          });
        });
      }
    });
    if (oldBody) {
      table.replaceChild(newBody, oldBody);
    } else {
      table.appendChild(newBody);
    }
  }
  addFolderPreviewHandler(element, files) {
    let tooltip = null;
    const showTooltip = (event) => {
      this.removeAllTooltips();
      tooltip = this.createFolderPreviewTooltip(files);
      document.body.appendChild(tooltip);
      this.positionTooltip(tooltip, event.target);
    };
    const hideTooltip = () => {
      if (tooltip) {
        tooltip.remove();
        tooltip = null;
      }
    };
    element.addEventListener("mouseenter", showTooltip);
    element.addEventListener("mouseleave", hideTooltip);
  }
  createFolderPreviewTooltip(files) {
    const tooltip = document.createElement("div");
    tooltip.addClass("folder-preview-tooltip");
    const previewContent = files.slice(0, 5).map((file) => `- ${file.name}`).join("\n");
    const moreFiles = files.length > 5 ? `
... \u0438 \u0435\u0449\u0435 ${files.length - 5} \u0444\u0430\u0439\u043B(\u043E\u0432)` : "";
    try {
      import_obsidian3.MarkdownRenderer.renderMarkdown(previewContent + moreFiles, tooltip, "", this);
    } catch (error) {
      console.error("Error rendering markdown for folder preview:", error);
      tooltip.textContent = "Error rendering preview";
    }
    return tooltip;
  }
  positionTooltip(tooltip, target) {
    const rect = target.getBoundingClientRect();
    const tooltipRect = tooltip.getBoundingClientRect();
    let top = rect.bottom + window.scrollY;
    let left = rect.left + window.scrollX;
    if (left + tooltipRect.width > window.innerWidth) {
      left = window.innerWidth - tooltipRect.width;
    }
    if (top + tooltipRect.height > window.innerHeight) {
      top = rect.top - tooltipRect.height + window.scrollY;
    }
    tooltip.style.top = `${top}px`;
    tooltip.style.left = `${left}px`;
  }
  capitalizeFirstLetter(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
  }
  formatFileSize(bytes) {
    if (bytes === 0)
      return "0 Bytes";
    const k = 1024;
    const sizes = ["Bytes", "KB", "MB", "GB", "TB"];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
  }
  groupFilesByFolder(files) {
    return files.reduce((acc, file) => {
      const folderPath = file.path.split("/").slice(0, -1).join("/");
      const folder = folderPath || "\u041A\u043E\u0440\u043D\u0435\u0432\u0430\u044F \u043F\u0430\u043F\u043A\u0430";
      if (!acc[folder])
        acc[folder] = [];
      acc[folder].push(file);
      return acc;
    }, {});
  }
  sortBy(column) {
    if (this.sortColumn === column) {
      this.sortDirection = this.sortDirection === "asc" ? "desc" : "asc";
    } else {
      this.sortColumn = column;
      this.sortDirection = "asc";
    }
    this.applyFiltersAndSort();
    const table = this.containerEl.querySelector("table");
    if (table) {
      const headers = table.querySelectorAll("th button");
      headers.forEach((button) => {
        var _a;
        button.classList.remove("sort-indicator", "asc", "desc");
        if (((_a = button.textContent) == null ? void 0 : _a.toLowerCase()) === column) {
          button.classList.add("sort-indicator", this.sortDirection);
        }
      });
    }
    this.renderBody();
  }
  setFilter(column, value) {
    this.filters[column] = value;
    this.applyFiltersAndSort();
    this.renderBody();
  }
  applyFiltersAndSort() {
    this.filteredFiles = this.files.filter(
      (file) => Object.entries(this.filters).every(([column, filterValue]) => {
        if (!filterValue)
          return true;
        const fileValue = file[column];
        if (column === "size") {
          return this.formatFileSize(fileValue).toLowerCase().includes(filterValue.toLowerCase());
        }
        return fileValue.toString().toLowerCase().includes(filterValue.toLowerCase());
      }) && (this.currentFolder === "" || file.folder === this.currentFolder)
    );
    this.filteredFiles.sort((a, b) => {
      const aValue = a[this.sortColumn];
      const bValue = b[this.sortColumn];
      if (aValue < bValue)
        return this.sortDirection === "asc" ? -1 : 1;
      if (aValue > bValue)
        return this.sortDirection === "asc" ? 1 : -1;
      return 0;
    });
  }
  openFolder(folderPath) {
    this.setFolderFilter(folderPath);
    this.removeAllTooltips();
  }
  getFilesInFolder(folderPath) {
    return this.files.filter((file) => file.folder === folderPath);
  }
  goBack() {
    if (this.folderHistory.length > 0) {
      const previousFolder = this.folderHistory.pop();
      this.currentFolder = previousFolder;
      this.applyFiltersAndSort();
      this.renderBody();
      this.updateFolderDropdown();
    }
  }
  removeAllTooltips() {
    document.querySelectorAll(".folder-preview-tooltip").forEach((el) => el.remove());
  }
  updateFileTable(files, groupByFolder, folderFilter) {
    if (files) {
      this.setFiles(files);
    }
    if (groupByFolder !== void 0) {
      this.setGroupByFolder(groupByFolder);
    }
    if (folderFilter !== void 0) {
      this.setFolderFilter(folderFilter);
    }
  }
};

// src/ui/SettingsTab.ts
var import_obsidian4 = require("obsidian");
var import_obsidian5 = require("obsidian");
var SettingsTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian4.Setting(containerEl).setName("\u0420\u0430\u0441\u0448\u0438\u0440\u0435\u043D\u0438\u044F \u0444\u0430\u0439\u043B\u043E\u0432").setDesc("\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0440\u0430\u0441\u0448\u0438\u0440\u0435\u043D\u0438\u044F \u0444\u0430\u0439\u043B\u043E\u0432 \u0447\u0435\u0440\u0435\u0437 \u0437\u0430\u043F\u044F\u0442\u0443\u044E (\u043D\u0430\u043F\u0440\u0438\u043C\u0435\u0440: pdf,cdr,eps)").addText((text) => text.setPlaceholder("pdf,cdr,eps").setValue(this.plugin.settings.fileExtensions.join(",")).onChange(async (value) => {
      this.plugin.settings.fileExtensions = value.split(",").map((ext) => ext.trim());
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("\u0413\u0440\u0443\u043F\u043F\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u043F\u043E \u043F\u0430\u043F\u043A\u0430\u043C").setDesc("\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u0433\u0440\u0443\u043F\u043F\u0438\u0440\u043E\u0432\u043A\u0443 \u0444\u0430\u0439\u043B\u043E\u0432 \u043F\u043E \u043F\u0430\u043F\u043A\u0430\u043C").addToggle((toggle) => toggle.setValue(this.plugin.settings.groupByFolder).onChange(async (value) => {
      this.plugin.settings.groupByFolder = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("\u041C\u0435\u0441\u0442\u043E \u043E\u0442\u043A\u0440\u044B\u0442\u0438\u044F").setDesc("\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435, \u0433\u0434\u0435 \u043E\u0442\u043A\u0440\u044B\u0432\u0430\u0442\u044C \u0442\u0430\u0431\u043B\u0438\u0446\u0443 \u0444\u0430\u0439\u043B\u043E\u0432").addDropdown((dropdown) => dropdown.addOption("left", "\u0421\u043B\u0435\u0432\u0430").addOption("right", "\u0421\u043F\u0440\u0430\u0432\u0430").addOption("main", "\u0412 \u0433\u043B\u0430\u0432\u043D\u043E\u043C \u043E\u043A\u043D\u0435").setValue(this.plugin.settings.openLocation).onChange(async (value) => {
      this.plugin.settings.openLocation = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("CSS \u0444\u0430\u0439\u043B").setDesc("\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 CSS \u0444\u0430\u0439\u043B \u0434\u043B\u044F \u0441\u0442\u0438\u043B\u0438\u0437\u0430\u0446\u0438\u0438 \u0442\u0430\u0431\u043B\u0438\u0446\u044B \u0444\u0430\u0439\u043B\u043E\u0432").addDropdown(async (dropdown) => {
      const cssFiles = await this.getCSSFiles();
      cssFiles.forEach((file) => {
        dropdown.addOption(file, file);
      });
      dropdown.setValue(this.plugin.settings.cssFile);
      dropdown.onChange(async (value) => {
        this.plugin.settings.cssFile = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian4.Setting(containerEl).setName("\u0421\u043A\u0430\u043D\u0438\u0440\u0443\u0435\u043C\u044B\u0435 \u043F\u0430\u043F\u043A\u0438").setDesc("\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u043F\u0430\u043F\u043A\u0438 \u0434\u043B\u044F \u0441\u043A\u0430\u043D\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u044F").addButton((button) => button.setButtonText("\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u043F\u0430\u043F\u043A\u0443").onClick(() => {
      new FolderSuggestModal(this.app, (folder) => {
        if (!this.plugin.settings.scannedFolders.includes(folder)) {
          this.plugin.settings.scannedFolders.push(folder);
          this.plugin.saveSettings();
          this.display();
        }
      }).open();
    }));
    this.plugin.settings.scannedFolders.forEach((folder) => {
      new import_obsidian4.Setting(containerEl).setName(folder || "\u041A\u043E\u0440\u043D\u0435\u0432\u0430\u044F \u043F\u0430\u043F\u043A\u0430").addButton((button) => button.setButtonText("\u0423\u0434\u0430\u043B\u0438\u0442\u044C").onClick(async () => {
        this.plugin.settings.scannedFolders = this.plugin.settings.scannedFolders.filter((f) => f !== folder);
        await this.plugin.saveSettings();
        this.display();
      }));
    });
  }
  async getCSSFiles() {
    const cssFiles = [];
    const pluginDir = (0, import_obsidian4.normalizePath)(this.app.vault.configDir + "/plugins/file-table-plugin");
    try {
      const pluginFiles = await this.app.vault.adapter.list(pluginDir);
      pluginFiles.files.filter((file) => file.endsWith(".css")).forEach((file) => cssFiles.push((0, import_obsidian4.normalizePath)(file)));
    } catch (error) {
      console.error("Failed to read plugin directory:", error);
    }
    cssFiles.push("styles.css");
    cssFiles.push("altstyles.css");
    const uniqueCssFiles = Array.from(new Set(cssFiles)).sort();
    console.log("Available CSS files:", uniqueCssFiles);
    return uniqueCssFiles;
  }
  getFolders() {
    const folders = [{ path: "", name: "\u041A\u043E\u0440\u043D\u0435\u0432\u0430\u044F \u043F\u0430\u043F\u043A\u0430" }];
    const iterateFolder = (folder, path = "") => {
      folder.children.forEach((child) => {
        if (child instanceof import_obsidian4.TFolder) {
          const childPath = path ? `${path}/${child.name}` : child.name;
          folders.push({ path: childPath, name: childPath });
          iterateFolder(child, childPath);
        }
      });
    };
    iterateFolder(this.app.vault.getRoot());
    return folders;
  }
};
var FolderSuggestModal = class extends import_obsidian5.FuzzySuggestModal {
  constructor(app, selectFolder) {
    super(app);
    this.selectFolder = selectFolder;
  }
  getItems() {
    return ["", ...this.getAllFolderPaths()];
  }
  getItemText(item) {
    return item || "\u041A\u043E\u0440\u043D\u0435\u0432\u0430\u044F \u043F\u0430\u043F\u043A\u0430";
  }
  onChooseItem(item, evt) {
    this.selectFolder(item);
  }
  renderSuggestion(item, el) {
    el.setText(this.getItemText(item.item));
  }
  getAllFolderPaths() {
    const folders = [];
    const stack = [this.app.vault.getRoot()];
    while (stack.length > 0) {
      const currentFolder = stack.pop();
      folders.push(currentFolder.path);
      currentFolder.children.filter((child) => child instanceof import_obsidian4.TFolder).forEach((childFolder) => stack.push(childFolder));
    }
    return folders;
  }
};

// src/ui/FolderFilterModal.ts
var import_obsidian6 = require("obsidian");
var FolderFilterModal = class extends import_obsidian6.FuzzySuggestModal {
  constructor(app, folderService, onChoose) {
    super(app);
    this.folderService = folderService;
    this.onChoose = onChoose;
  }
  getItems() {
    return ["", ...this.folderService.getFolders().map((folder) => folder.path)];
  }
  getItemText(item) {
    return item || "\u041A\u043E\u0440\u043D\u0435\u0432\u0430\u044F \u043F\u0430\u043F\u043A\u0430";
  }
  onChooseItem(item, evt) {
    this.onChoose(item);
  }
  renderSuggestion(item, el) {
    el.setText(this.getItemText(item.item));
  }
};

// src/FileTablePlugin.ts
var DEFAULT_SETTINGS = {
  fileExtensions: ["pdf", "cdr", "eps", "png", "jpg", "doc", "docx"],
  groupByFolder: true,
  openLocation: "right",
  cssFile: "styles.css",
  scannedFolders: [""]
  // Пустая строка означает корневую папку
};
var FileTablePlugin = class extends import_obsidian7.Plugin {
  constructor() {
    super(...arguments);
    this.currentStyleElement = null;
  }
  async onload() {
    await this.loadSettings();
    this.fileService = new FileService(this.app.vault, this.app);
    this.folderService = new FolderService(this.app.vault);
    this.addSettingTab(new SettingsTab(this.app, this));
    this.registerView(FILE_TABLE_VIEW_TYPE, (leaf) => {
      this.fileTableView = new FileTableView(leaf, this);
      return this.fileTableView;
    });
    this.addRibbonIcon("table", "Open File Table", () => {
      this.activateView();
    });
    this.app.workspace.onLayoutReady(() => {
      this.activateView();
    });
    this.registerEvent(this.app.vault.on("create", () => this.updateFileTable()));
    this.registerEvent(this.app.vault.on("delete", () => this.updateFileTable()));
    this.registerEvent(this.app.vault.on("rename", () => this.updateFileTable()));
    this.registerEvent(this.app.vault.on("modify", () => this.updateFileTable()));
    await this.loadSelectedCSS();
    this.updateFileTable();
    this.addCommand({
      id: "open-folder-filter-modal",
      name: "\u041E\u0442\u043A\u0440\u044B\u0442\u044C \u043C\u043E\u0434\u0430\u043B\u044C\u043D\u043E\u0435 \u043E\u043A\u043D\u043E \u0444\u0438\u043B\u044C\u0442\u0440\u0430\u0446\u0438\u0438 \u043F\u043E \u043F\u0430\u043F\u043A\u0430\u043C",
      callback: () => {
        new FolderFilterModal(this.app, this.folderService, (folder) => {
          if (this.fileTableView) {
            this.fileTableView.updateFileTable(void 0, void 0, folder);
          }
        }).open();
      }
    });
  }
  async loadSelectedCSS() {
    if (this.currentStyleElement) {
      this.currentStyleElement.remove();
    }
    let cssContent;
    try {
      const cssPath = (0, import_obsidian7.normalizePath)(this.manifest.dir + "/" + this.settings.cssFile);
      cssContent = await this.app.vault.adapter.read(cssPath);
    } catch (error) {
      console.error(`Failed to load CSS file: ${this.settings.cssFile}`, error);
      cssContent = await this.loadDefaultCSS();
    }
    this.currentStyleElement = document.createElement("style");
    this.currentStyleElement.textContent = cssContent;
    document.head.appendChild(this.currentStyleElement);
  }
  async loadDefaultCSS() {
    return `
      .file-table-container { /* Default styles */ }
      .file-table { /* Default styles */ }
      /* Add more default styles here */
    `;
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    await this.loadSelectedCSS();
    this.updateFileTable();
  }
  async updateFileTable() {
    if (this.fileTableView) {
      const files = await this.getAllFilesInScannedFolders();
      this.fileTableView.updateFileTable(files, this.settings.groupByFolder);
    }
  }
  async getAllFilesInScannedFolders() {
    const allFiles = [];
    for (const folder of this.settings.scannedFolders) {
      const files = await this.fileService.getFilesInFolder(folder, this.settings.fileExtensions);
      allFiles.push(...files);
    }
    return allFiles;
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(FILE_TABLE_VIEW_TYPE);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getLeaf(false);
      await leaf.setViewState({ type: FILE_TABLE_VIEW_TYPE, active: true });
    }
    workspace.revealLeaf(leaf);
  }
  // Публичные методы для доступа к функциональности fileService
  async getFilesInFolder(folderPath, extensions) {
    return this.fileService.getFilesInFolder(folderPath, extensions);
  }
  openFile(path) {
    this.fileService.openFile(path);
  }
};
var FILE_TABLE_VIEW_TYPE = "file-table-view";
var FileTableView = class extends import_obsidian7.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
  }
  getViewType() {
    return FILE_TABLE_VIEW_TYPE;
  }
  getDisplayText() {
    return "File Table";
  }
  async onOpen() {
    this.fileTable = new FileTable(this.containerEl, (path) => this.plugin.openFile(path));
    await this.updateFileTable();
  }
  async onClose() {
  }
  async updateFileTable(files, groupByFolder, folderFilter) {
    if (!files) {
      files = await this.plugin.getAllFilesInScannedFolders();
    }
    if (groupByFolder === void 0) {
      groupByFolder = this.plugin.settings.groupByFolder;
    }
    this.fileTable.updateFileTable(files, groupByFolder, folderFilter);
  }
};

// src/main.ts
var MainPlugin = class extends import_obsidian8.Plugin {
  async onload() {
    this.fileTablePlugin = new FileTablePlugin(this.app, this.manifest);
    await this.fileTablePlugin.onload();
  }
  async onunload() {
    await this.fileTablePlugin.onunload();
  }
};
