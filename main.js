/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MainPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian10 = require("obsidian");

// src/FileTablePlugin.ts
var import_obsidian9 = require("obsidian");

// src/services/FileService.ts
var import_obsidian = require("obsidian");

// src/services/MetadataService.ts
var MetadataService = class {
  constructor(vault) {
    this.vault = vault;
  }
  async getFileInfo(file) {
    const stat = await this.vault.adapter.stat(file.path);
    if (!stat) {
      throw new Error(`Unable to get stats for file: ${file.path}`);
    }
    return {
      name: file.name,
      extension: file.extension,
      createdAt: new Date(stat.ctime),
      modifiedAt: new Date(stat.mtime),
      size: stat.size,
      path: file.path,
      icon: this.getIconForFileType(file.extension),
      folder: this.getFolderPath(file.path)
      // Добавляем путь к папке
    };
  }
  getIconForFileType(extension) {
    const iconMap = {
      pdf: "file-pdf",
      doc: "file-word",
      docx: "file-word",
      xls: "file-excel",
      xlsx: "file-excel",
      ppt: "file-powerpoint",
      pptx: "file-powerpoint",
      jpg: "file-image",
      jpeg: "file-image",
      png: "file-image",
      gif: "file-image",
      mp3: "file-audio",
      wav: "file-audio",
      mp4: "file-video",
      avi: "file-video",
      zip: "file-archive",
      rar: "file-archive"
      // Добавьте другие расширения и соответствующие им иконки
    };
    return iconMap[extension.toLowerCase()] || "file";
  }
  getFolderPath(filePath) {
    const parts = filePath.split("/");
    parts.pop();
    return parts.join("/") || "/";
  }
};

// src/services/FileService.ts
var FileService = class {
  constructor(vault, app) {
    this.vault = vault;
    this.app = app;
    this.metadataService = new MetadataService(vault);
  }
  async getFilesInFolder(folderPath, extensions) {
    const files = this.vault.getFiles().filter((file) => {
      const isInFolder = folderPath === "" || file.path.startsWith(folderPath);
      const hasCorrectExtension = extensions.includes(file.extension);
      return isInFolder && hasCorrectExtension;
    });
    const uniqueFiles = /* @__PURE__ */ new Map();
    files.forEach((file) => {
      if (!uniqueFiles.has(file.path)) {
        uniqueFiles.set(file.path, file);
      }
    });
    const fileInfoPromises = Array.from(uniqueFiles.values()).map((file) => this.metadataService.getFileInfo(file));
    return Promise.all(fileInfoPromises);
  }
  openFile(path) {
    const file = this.vault.getAbstractFileByPath(path);
    if (file instanceof import_obsidian.TFile) {
      const extension = file.extension.toLowerCase();
      const isImageOrPdf = ["png", "jpg", "jpeg", "gif", "bmp", "svg", "pdf"].includes(extension);
      let leaf;
      if (isImageOrPdf) {
        leaf = this.app.workspace.getLeaf("tab");
      } else {
        leaf = this.getLeaf();
      }
      leaf.openFile(file, { active: true });
    }
  }
  getLeaf() {
    const leaf = this.app.workspace.getMostRecentLeaf();
    if (leaf && !leaf.getViewState().pinned) {
      return leaf;
    }
    return this.app.workspace.getLeaf("tab");
  }
};

// src/services/FolderService.ts
var import_obsidian2 = require("obsidian");
var FolderService = class {
  constructor(vault) {
    this.vault = vault;
  }
  getFolders() {
    const folders = [{ name: "\u041A\u043E\u0440\u043D\u0435\u0432\u0430\u044F \u043F\u0430\u043F\u043A\u0430", path: "" }];
    this.traverseFolders(this.vault.getRoot(), folders);
    return folders;
  }
  traverseFolders(folder, result) {
    folder.children.forEach((child) => {
      if (child instanceof import_obsidian2.TFolder) {
        result.push({ name: child.name, path: child.path });
        this.traverseFolders(child, result);
      }
    });
  }
  // ... остальной код ...
};

// src/ui/FileTable.ts
var import_obsidian7 = require("obsidian");

// src/ui/FileTableUtils.ts
function formatFileSize(bytes) {
  if (bytes === 0)
    return "0 Bytes";
  const k = 1024;
  const sizes = ["Bytes", "KB", "MB", "GB", "TB"];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
}

// src/ui/FileTableRenderer.ts
var import_obsidian3 = require("obsidian");
var FileTableRenderer = class {
  constructor(fileTable, containerEl, onFileOpen, plugin) {
    this.fileTable = fileTable;
    this.containerEl = containerEl;
    this.onFileOpen = onFileOpen;
    this.plugin = plugin;
    this.filterInputs = {};
  }
  renderHeader(table) {
    const thead = table.createTHead();
    const row = thead.insertRow();
    const columns = ["name", "extension", "createdAt", "modifiedAt", "size", "folder"];
    columns.forEach((column) => {
      const th = row.createEl("th");
      th.dataset.column = column;
      const button = th.createEl("button");
      button.textContent = this.capitalizeFirstLetter(column);
      const sortIndicator = button.createSpan({ cls: "sort-indicator" });
      button.addEventListener("click", () => {
        this.fileTable.getSorter().sortBy(column);
        this.fileTable.applyFiltersAndSort();
        this.fileTable.updateTableContent();
        this.updateSortIndicators(thead);
        this.fileTable.saveTableState();
      });
      const input = th.createEl("input", { type: "text" });
      input.placeholder = `\u0424\u0438\u043B\u044C\u0442\u0440 ${column}`;
      this.filterInputs[column] = input;
      input.value = this.fileTable.getFilter().getFilters()[column] || "";
      input.addEventListener("input", (event) => {
        const filterValue = event.target.value;
        this.fileTable.getFilter().setFilter(column, filterValue);
        this.fileTable.applyFiltersAndSort();
        this.fileTable.updateTableContent();
        this.fileTable.saveTableState();
      });
    });
    this.updateSortIndicators(thead);
  }
  updateSortIndicators(thead) {
    const sortColumn = this.fileTable.getSorter().getSortColumn();
    const sortDirection = this.fileTable.getSorter().getSortDirection();
    thead.querySelectorAll("th button").forEach((button, index) => {
      const sortIndicator = button.querySelector(".sort-indicator");
      if (sortIndicator) {
        if (index === this.getColumnIndex(sortColumn)) {
          sortIndicator.textContent = sortDirection === "asc" ? " \u25B2" : " \u25BC";
        } else {
          sortIndicator.textContent = "";
        }
      }
    });
  }
  getColumnIndex(column) {
    const columns = ["name", "extension", "createdAt", "modifiedAt", "size", "folder"];
    return columns.indexOf(column);
  }
  renderBody(table, files, groupByFolder) {
    const tbody = table.createTBody();
    const groupedFiles = groupByFolder ? this.groupFilesByFolder(files) : { "": files };
    for (const [folder, folderFiles] of Object.entries(groupedFiles)) {
      if (groupByFolder && folder !== "") {
        this.renderFolderHeader(tbody, folder);
      }
      folderFiles.forEach((file) => {
        const row = tbody.insertRow();
        this.renderCell(row, "name", this.renderFileName(file));
        this.renderCell(row, "extension", file.extension);
        this.renderCell(row, "createdAt", file.createdAt.toLocaleString());
        this.renderCell(row, "modifiedAt", file.modifiedAt.toLocaleString());
        this.renderCell(row, "size", formatFileSize(file.size));
        this.renderCell(row, "folder", file.folder);
      });
    }
  }
  renderFolderHeader(tbody, folder) {
    const row = tbody.insertRow();
    row.classList.add("folder-header");
    const cell = row.insertCell();
    cell.colSpan = 5;
    const folderParts = folder.split("/");
    const folderName = folderParts[folderParts.length - 1] || "\u041A\u043E\u0440\u043D\u0435\u0432\u0430\u044F \u043F\u0430\u043F\u043A\u0430";
    const folderPath = folderParts.slice(0, -1).join("/");
    const folderNameEl = cell.createSpan({ cls: "folder-name" });
    folderNameEl.textContent = folderName;
    if (folderPath) {
      const folderPathEl = cell.createSpan({ cls: "folder-path" });
      folderPathEl.textContent = ` (${folderPath})`;
    }
    const ignoreCell = row.insertCell();
    new import_obsidian3.ButtonComponent(ignoreCell).setIcon("cross").setTooltip("\u0418\u0433\u043D\u043E\u0440\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u043F\u0430\u043F\u043A\u0443").setClass("ignore-folder-button").onClick((e) => {
      e.stopPropagation();
      this.fileTable.getFolderManager().addIgnoredFolder(folder);
    });
  }
  renderFileName(file) {
    const nameLink = createEl("a", { cls: "file-name-link", text: file.name });
    nameLink.addEventListener("click", (e) => {
      e.preventDefault();
      this.onFileOpen(file.path);
    });
    return nameLink;
  }
  renderCell(row, column, content) {
    const cell = row.insertCell();
    if (typeof content === "string") {
      cell.textContent = content;
    } else {
      cell.appendChild(content);
    }
  }
  capitalizeFirstLetter(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
  }
  groupFilesByFolder(files) {
    return files.reduce((acc, file) => {
      const folder = file.folder || "\u041A\u043E\u0440\u043D\u0435\u0432\u0430\u044F \u043F\u0430\u043F\u043A\u0430";
      if (!acc[folder]) {
        acc[folder] = [];
      }
      acc[folder].push(file);
      return acc;
    }, {});
  }
  renderControls(containerEl) {
    const controlsEl = containerEl.createDiv({ cls: "file-table-controls" });
    this.renderCompactFolderSettings(controlsEl);
    this.renderPaginationControls(controlsEl);
    this.renderBookmarkControls(containerEl);
  }
  render(containerEl, files, groupByFolder) {
    console.log("Rendering table");
    const table = containerEl.createEl("table", { cls: "file-table" });
    this.renderHeader(table);
    this.renderBody(table, files, groupByFolder);
    this.fileTable.getColumnResizer().makeColumnsResizable(table);
    console.log("Table rendered");
  }
  update() {
    const activeElement = document.activeElement;
    const focusedColumn = activeElement instanceof HTMLInputElement ? Object.keys(this.filterInputs).find((key) => this.filterInputs[key] === activeElement) : null;
    this.containerEl.empty();
    this.renderControls(this.containerEl);
    const tableWrapper = this.containerEl.createDiv({ cls: "file-table-wrapper" });
    const filesToRender = this.fileTable.getPaginationManager().getCurrentPageFiles();
    this.render(tableWrapper, filesToRender, this.fileTable.getGroupByFolder());
    if (focusedColumn) {
      const newInput = this.filterInputs[focusedColumn];
      if (newInput) {
        newInput.focus();
        newInput.setSelectionRange(newInput.value.length, newInput.value.length);
      }
    }
  }
  renderCompactFolderSettings(containerEl) {
    const settingsEl = containerEl.createDiv({ cls: "compact-folder-settings" });
    new import_obsidian3.ButtonComponent(settingsEl).setIcon("folder-plus").setTooltip("\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u043F\u0430\u043F\u043A\u0443 \u0434\u043B\u044F \u0441\u043A\u0430\u043D\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u044F").onClick(() => this.fileTable.getFolderManager().openFolderSelectorWithCallback(
      async (folder) => {
        await this.fileTable.getFolderManager().addFolder(folder);
        this.update();
      }
    ));
    new import_obsidian3.ButtonComponent(settingsEl).setIcon("folder-minus").setTooltip("\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u043F\u0430\u043F\u043A\u0443 \u0432 \u0438\u0433\u043D\u043E\u0440\u0438\u0440\u0443\u0435\u043C\u044B\u0435").onClick(() => this.fileTable.getFolderManager().openFolderSelectorWithCallback(
      async (folder) => {
        await this.fileTable.getFolderManager().addIgnoredFolder(folder);
        this.update();
      }
    ));
    new import_obsidian3.ButtonComponent(settingsEl).setIcon("trash").setTooltip("\u041E\u0447\u0438\u0441\u0442\u0438\u0442\u044C \u0432\u0441\u0435 \u043F\u0430\u043F\u043A\u0438").onClick(async () => {
      await this.fileTable.getFolderManager().clearAllFolders();
      this.update();
    });
    const paginationSelect = settingsEl.createEl("select", { cls: "pagination-select" });
    [10, 20, 50, 100, 500].forEach((value) => {
      const option = paginationSelect.createEl("option", { value: value.toString(), text: value.toString() });
      if (value === this.fileTable.getPaginationManager().getPageSize()) {
        option.selected = true;
      }
    });
    paginationSelect.addEventListener("change", (event) => {
      const newPageSize = parseInt(event.target.value);
      this.fileTable.getPaginationManager().setPageSize(newPageSize);
      this.fileTable.applyFiltersAndSort();
      this.update();
      this.fileTable.saveTableState();
    });
  }
  renderPaginationControls(containerEl) {
    const paginationEl = containerEl.createDiv({ cls: "pagination-controls" });
    new import_obsidian3.ButtonComponent(paginationEl).setIcon("arrow-left").setTooltip("\u041F\u0440\u0435\u0434\u044B\u0434\u0443\u0449\u0430\u044F \u0441\u0442\u0440\u0430\u043D\u0438\u0446\u0430").onClick(() => {
      this.fileTable.getPaginationManager().prevPage();
      this.update();
    });
    const pageInfoEl = paginationEl.createSpan({ cls: "page-info" });
    const currentPage = this.fileTable.getPaginationManager().getCurrentPage();
    const totalPages = this.fileTable.getPaginationManager().getTotalPages();
    pageInfoEl.textContent = `\u0421\u0442\u0440\u0430\u043D\u0438\u0446\u0430 ${currentPage} \u0438\u0437 ${totalPages}`;
    new import_obsidian3.ButtonComponent(paginationEl).setIcon("arrow-right").setTooltip("\u0421\u043B\u0435\u0434\u0443\u044E\u0449\u0430\u044F \u0441\u0442\u0440\u0430\u043D\u0438\u0446\u0430").onClick(() => {
      this.fileTable.getPaginationManager().nextPage();
      this.update();
    });
  }
  renderBookmarkControls(containerEl) {
    const bookmarkControlsEl = containerEl.createDiv({ cls: "bookmark-controls" });
    const inputEl = new import_obsidian3.TextComponent(bookmarkControlsEl).setPlaceholder("\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0442\u0435\u0433 \u0434\u043B\u044F \u0437\u0430\u043A\u043B\u0430\u0434\u043A\u0438").inputEl;
    new import_obsidian3.ButtonComponent(bookmarkControlsEl).setButtonText("\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u0437\u0430\u043A\u043B\u0430\u0434\u043A\u0443").onClick(() => {
      const tag = inputEl.value.trim();
      if (tag) {
        this.fileTable.getBookmarks().addBookmark(tag);
        inputEl.value = "";
        this.update();
      }
    });
    const bookmarksEl = containerEl.createDiv({ cls: "file-table-bookmarks" });
    this.fileTable.getBookmarks().renderBookmarks(bookmarksEl);
    const activeBookmarkEl = containerEl.createDiv({ cls: "active-bookmark" });
    const activeBookmark = this.fileTable.getBookmarks().getActiveBookmark();
    if (activeBookmark) {
      activeBookmarkEl.textContent = `\u0410\u043A\u0442\u0438\u0432\u043D\u044B\u0439 \u0444\u0438\u043B\u044C\u0442\u0440: ${activeBookmark}`;
    }
  }
};

// src/ui/FileTableSorter.ts
var FileTableSorter = class {
  constructor() {
    this.sortColumn = "name";
    this.sortDirection = "asc";
  }
  sortBy(column) {
    if (this.sortColumn === column) {
      this.sortDirection = this.sortDirection === "asc" ? "desc" : "asc";
    } else {
      this.sortColumn = column;
      this.sortDirection = "asc";
    }
  }
  setSortColumn(column) {
    this.sortColumn = column;
  }
  setSortDirection(direction) {
    this.sortDirection = direction;
  }
  sortFiles(files) {
    return [...files].sort((a, b) => {
      const aValue = a[this.sortColumn];
      const bValue = b[this.sortColumn];
      if (aValue instanceof Date && bValue instanceof Date) {
        return this.sortDirection === "asc" ? aValue.getTime() - bValue.getTime() : bValue.getTime() - aValue.getTime();
      }
      if (typeof aValue === "string" && typeof bValue === "string") {
        return this.sortDirection === "asc" ? aValue.localeCompare(bValue) : bValue.localeCompare(aValue);
      }
      if (typeof aValue === "number" && typeof bValue === "number") {
        return this.sortDirection === "asc" ? aValue - bValue : bValue - aValue;
      }
      return 0;
    });
  }
  getSortColumn() {
    return this.sortColumn;
  }
  getSortDirection() {
    return this.sortDirection;
  }
};

// src/ui/FileTableFilter.ts
var FileTableFilter = class {
  constructor() {
    this.filters = {};
  }
  setFilter(column, value) {
    this.filters[column] = value;
  }
  // New method to set multiple filters
  setFilters(filters) {
    this.filters = { ...this.filters, ...filters };
  }
  applyFilters(files, currentFolder, selectedFolders) {
    return files.filter(
      (file) => Object.entries(this.filters).every(([column, filterValue]) => {
        if (!filterValue)
          return true;
        const fileValue = file[column];
        return String(fileValue).toLowerCase().includes(filterValue.toLowerCase());
      }) && (currentFolder === "" || file.folder === currentFolder) && (selectedFolders.length === 0 || selectedFolders.includes(file.folder))
    );
  }
  getFilters() {
    return this.filters;
  }
};

// src/ui/FolderManager.ts
var import_obsidian5 = require("obsidian");

// src/ui/FolderSuggestModal.ts
var import_obsidian4 = require("obsidian");
var FolderSuggestModal = class extends import_obsidian4.FuzzySuggestModal {
  constructor(app, selectFolder) {
    super(app);
    this.selectFolder = selectFolder;
  }
  getItems() {
    return ["", ...this.getAllFolderPaths()];
  }
  getItemText(item) {
    return item || "\u041A\u043E\u0440\u043D\u0435\u0432\u0430\u044F \u043F\u0430\u043F\u043A\u0430";
  }
  onChooseItem(item, evt) {
    this.selectFolder(item);
  }
  renderSuggestion(item, el) {
    el.setText(this.getItemText(item.item));
  }
  getAllFolderPaths() {
    const folders = [];
    const stack = [this.app.vault.getRoot()];
    while (stack.length > 0) {
      const currentFolder = stack.pop();
      folders.push(currentFolder.path);
      currentFolder.children.filter((child) => child instanceof import_obsidian4.TFolder).forEach((childFolder) => stack.push(childFolder));
    }
    return folders;
  }
};

// src/ui/FolderManager.ts
var FolderManager = class {
  constructor(fileTable, plugin) {
    this.fileTable = fileTable;
    this.plugin = plugin;
    this.selectedFolders = /* @__PURE__ */ new Set();
  }
  openFolderSelectorWithCallback(callback) {
    new FolderSuggestModal(this.plugin.app, callback).open();
  }
  async addFolder(folder) {
    if (!this.plugin.settings.scannedFolders.includes(folder)) {
      this.plugin.settings.scannedFolders.push(folder);
      await this.plugin.saveSettings();
      await this.plugin.updateFileTable();
    }
  }
  async removeFolder(folder) {
    const index = this.plugin.settings.scannedFolders.indexOf(folder);
    if (index > -1) {
      this.plugin.settings.scannedFolders.splice(index, 1);
      await this.plugin.saveSettings();
      await this.plugin.updateFileTable();
    }
  }
  async addIgnoredFolder(folder) {
    if (!this.plugin.settings.ignoredFolders.includes(folder)) {
      this.plugin.settings.ignoredFolders.push(folder);
      await this.plugin.saveSettings();
      await this.plugin.updateFileTable();
    }
  }
  async removeIgnoredFolder(folder) {
    const index = this.plugin.settings.ignoredFolders.indexOf(folder);
    if (index > -1) {
      this.plugin.settings.ignoredFolders.splice(index, 1);
      await this.plugin.saveSettings();
      await this.plugin.updateFileTable();
    }
  }
  async toggleFolderSelection(folder) {
    if (this.selectedFolders.has(folder)) {
      this.selectedFolders.delete(folder);
    } else {
      this.selectedFolders.add(folder);
    }
    await this.plugin.updateFileTable();
  }
  getSelectedFolders() {
    return new Set(this.selectedFolders);
  }
  setSelectedFolders(folders) {
    this.selectedFolders = new Set(folders);
  }
  async clearAllFolders() {
    this.selectedFolders.clear();
    this.plugin.settings.scannedFolders = [];
    await this.plugin.saveSettings();
    await this.plugin.updateFileTable();
    new import_obsidian5.Notice("\u0412\u0441\u0435 \u043F\u0430\u043F\u043A\u0438 \u043E\u0447\u0438\u0449\u0435\u043D\u044B");
  }
  clearFolders() {
    this.selectedFolders.clear();
    this.fileTable.setCurrentFolder("");
  }
};

// src/ui/PaginationManager.ts
var PaginationManager = class {
  constructor(fileTable) {
    this.fileTable = fileTable;
    this.currentPage = 1;
    this.pageSize = 20;
    this.totalPages = 1;
  }
  setPageSize(size) {
    this.pageSize = size;
    this.resetCurrentPage();
  }
  getPageSize() {
    return this.pageSize;
  }
  getCurrentPage() {
    return this.currentPage;
  }
  getTotalPages() {
    return this.totalPages;
  }
  updateTotalPages(totalItems) {
    this.totalPages = Math.ceil(totalItems / this.pageSize);
  }
  resetCurrentPage() {
    this.currentPage = 1;
  }
  prevPage() {
    if (this.currentPage > 1) {
      this.currentPage--;
    }
  }
  nextPage() {
    if (this.currentPage < this.totalPages) {
      this.currentPage++;
    }
  }
  getCurrentPageFiles() {
    const startIndex = (this.currentPage - 1) * this.pageSize;
    const endIndex = Math.min(startIndex + this.pageSize, this.fileTable.getFilteredFiles().length);
    return this.fileTable.getFilteredFiles().slice(startIndex, endIndex);
  }
  setCurrentPage(page) {
    if (page >= 1 && page <= this.totalPages) {
      this.currentPage = page;
    }
  }
};

// src/ui/SessionManager.ts
var SessionManager = class {
  constructor(fileTable, plugin) {
    this.fileTable = fileTable;
    this.plugin = plugin;
  }
  async loadSession() {
    const savedSession = await this.plugin.loadData();
    if (savedSession && savedSession.fileTableSession) {
      const session = savedSession.fileTableSession;
      if (this.plugin.settings.saveFoldersBetweenSessions) {
        this.fileTable.getFolderManager().setSelectedFolders(session.selectedFolders || []);
        this.fileTable.setCurrentFolder(session.currentFolder || "");
        this.plugin.settings.scannedFolders = session.scannedFolders || this.plugin.settings.scannedFolders;
        this.plugin.settings.ignoredFolders = session.ignoredFolders || this.plugin.settings.ignoredFolders;
      }
      this.fileTable.getPaginationManager().setPageSize(session.pageSize || 50);
      this.fileTable.getPaginationManager().setCurrentPage(session.currentPage || 1);
      this.fileTable.applyFiltersAndSort();
      this.fileTable.updateTableContent();
    }
  }
  async saveSession() {
    const sessionData = {
      pageSize: this.fileTable.getPaginationManager().getPageSize(),
      currentPage: this.fileTable.getPaginationManager().getCurrentPage()
    };
    if (this.plugin.settings.saveFoldersBetweenSessions) {
      sessionData.selectedFolders = Array.from(this.fileTable.getFolderManager().getSelectedFolders());
      sessionData.currentFolder = this.fileTable.getCurrentFolder();
      sessionData.scannedFolders = this.plugin.settings.scannedFolders;
      sessionData.ignoredFolders = this.plugin.settings.ignoredFolders;
    }
    await this.plugin.saveData({
      fileTableSession: sessionData
    });
  }
};

// src/ui/ColumnResizer.ts
var ColumnResizer = class {
  constructor(fileTable, plugin) {
    this.fileTable = fileTable;
    this.plugin = plugin;
    this.columnWidths = {};
    this.loadColumnWidths();
  }
  makeColumnsResizable(table) {
    const headers = table.querySelectorAll("th");
    headers.forEach((header, index) => {
      const column = header.dataset.column;
      if (column && this.columnWidths[column]) {
        header.style.width = this.columnWidths[column];
      }
      const resizer = header.createEl("div", { cls: "resizer" });
      let startX, startWidth;
      const onMouseMove = (e) => {
        const dx = e.clientX - startX;
        const newWidth = `${startWidth + dx}px`;
        header.style.width = newWidth;
        if (column) {
          this.columnWidths[column] = newWidth;
        }
        const cells = table.querySelectorAll(`td:nth-child(${index + 1})`);
        cells.forEach((cell) => cell.style.width = newWidth);
      };
      const onMouseUp = () => {
        document.removeEventListener("mousemove", onMouseMove);
        document.removeEventListener("mouseup", onMouseUp);
        this.saveColumnWidths();
      };
      resizer.addEventListener("mousedown", (e) => {
        startX = e.clientX;
        startWidth = header.offsetWidth;
        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("mouseup", onMouseUp);
      });
    });
  }
  async saveColumnWidths() {
    await this.plugin.saveData({
      ...await this.plugin.loadData(),
      columnWidths: this.columnWidths
    });
  }
  async loadColumnWidths() {
    const data = await this.plugin.loadData();
    if (data.columnWidths) {
      this.columnWidths = data.columnWidths;
    }
  }
  getColumnWidths() {
    return this.columnWidths;
  }
};

// src/ui/Bookmarks.ts
var import_obsidian6 = require("obsidian");
var Bookmarks = class {
  constructor(fileTable, plugin) {
    this.fileTable = fileTable;
    this.plugin = plugin;
    this.bookmarks = [];
    this.activeBookmark = null;
  }
  addBookmark(tag) {
    if (!this.bookmarks.includes(tag)) {
      this.bookmarks.push(tag);
      this.fileTable.saveTableState();
      this.filterByTag(tag);
    }
  }
  removeBookmark(tag) {
    this.bookmarks = this.bookmarks.filter((b) => b !== tag);
    this.fileTable.saveTableState();
    if (this.activeBookmark === tag) {
      this.clearFilter();
    } else {
      this.fileTable.updateTableContent();
    }
  }
  renderBookmarks(containerEl) {
    containerEl.empty();
    this.bookmarks.forEach((tag) => {
      const bookmarkEl = containerEl.createDiv({ cls: "bookmark-tag" });
      new import_obsidian6.ButtonComponent(bookmarkEl).setButtonText(tag).onClick(() => this.filterByTag(tag));
      new import_obsidian6.ButtonComponent(bookmarkEl).setIcon("x").setTooltip("\u0423\u0434\u0430\u043B\u0438\u0442\u044C \u0437\u0430\u043A\u043B\u0430\u0434\u043A\u0443").onClick(() => this.removeBookmark(tag));
    });
    if (this.activeBookmark) {
      new import_obsidian6.ButtonComponent(containerEl).setButtonText("\u0421\u0431\u0440\u043E\u0441\u0438\u0442\u044C \u0444\u0438\u043B\u044C\u0442\u0440").setTooltip("\u0421\u0431\u0440\u043E\u0441\u0438\u0442\u044C \u0444\u0438\u043B\u044C\u0442\u0440 \u043F\u043E \u0437\u0430\u043A\u043B\u0430\u0434\u043A\u0430\u043C").onClick(() => this.clearFilter());
    }
  }
  async filterByTag(tag) {
    this.activeBookmark = tag;
    const allFiles = await this.getAllFilesInVault();
    const filteredFiles = allFiles.filter(
      (file) => file.folder.toLowerCase().includes(tag.toLowerCase())
    );
    this.fileTable.updateFileTable(filteredFiles, this.plugin.settings.groupByFolder);
    this.fileTable.render();
  }
  async clearFilter() {
    this.activeBookmark = null;
    const files = await this.getFilesInScannedFolders();
    this.fileTable.updateFileTable(files, this.plugin.settings.groupByFolder);
    this.fileTable.render();
  }
  // Обновленный метод для получения файлов из сканируемых папок
  async getFilesInScannedFolders() {
    const allFiles = await this.getAllFilesInVault();
    const scannedFolders = this.plugin.settings.scannedFolders;
    const ignoredFolders = this.plugin.settings.ignoredFolders;
    if (scannedFolders.length === 0) {
      return [];
    }
    return allFiles.filter(
      (file) => this.isInScannedFolder(file.path, scannedFolders) && !this.isInIgnoredFolder(file.path, ignoredFolders)
    );
  }
  isInScannedFolder(filePath, scannedFolders) {
    return scannedFolders.some(
      (folder) => filePath === folder || filePath.startsWith(folder + "/")
    );
  }
  isInIgnoredFolder(filePath, ignoredFolders) {
    return ignoredFolders.some(
      (folder) => filePath === folder || filePath.startsWith(folder + "/")
    );
  }
  // Обновленный метод для получения всех файлов в хранилище
  async getAllFilesInVault() {
    const allFiles = [];
    const vault = this.plugin.app.vault;
    for (const file of vault.getFiles()) {
      if (this.plugin.settings.fileExtensions.includes(file.extension)) {
        const fileInfo = {
          name: file.name,
          path: file.path,
          extension: file.extension,
          size: file.stat.size,
          createdAt: new Date(file.stat.ctime),
          modifiedAt: new Date(file.stat.mtime),
          folder: file.parent ? file.parent.path : "",
          icon: this.getFileIcon(file.extension)
        };
        allFiles.push(fileInfo);
      }
    }
    return allFiles;
  }
  getFileIcon(extension) {
    switch (extension.toLowerCase()) {
      case "pdf":
        return "pdf";
      case "cdr":
      case "eps":
        return "image-file";
      default:
        return "document";
    }
  }
  getBookmarks() {
    return this.bookmarks;
  }
  setBookmarks(bookmarks) {
    this.bookmarks = bookmarks;
    this.activeBookmark = null;
    this.fileTable.updateTableContent();
  }
  getActiveBookmark() {
    return this.activeBookmark;
  }
};

// src/ui/FileTable.ts
var FileTable = class extends import_obsidian7.Component {
  constructor(containerEl, onFileOpen, plugin) {
    super();
    this.containerEl = containerEl;
    this.onFileOpen = onFileOpen;
    this.plugin = plugin;
    this.files = [];
    this.filteredFiles = [];
    this.groupByFolder = false;
    this.currentFolder = "";
    this.currentPage = 1;
    // Added to track current page
    this.totalPages = 1;
    // Added to track total pages
    this.itemsPerPage = 20;
    this.renderer = new FileTableRenderer(this, containerEl, onFileOpen, plugin);
    this.sorter = new FileTableSorter();
    this.filter = new FileTableFilter();
    this.folderManager = new FolderManager(this, plugin);
    this.paginationManager = new PaginationManager(this);
    this.sessionManager = new SessionManager(this, plugin);
    this.columnResizer = new ColumnResizer(this, plugin);
    this.bookmarks = new Bookmarks(this, plugin);
    if (this.plugin.settings.saveFoldersBetweenSessions) {
      this.sessionManager.loadSession();
    } else {
      this.render();
    }
  }
  render() {
    console.log("Rendering table");
    this.renderer.update();
    console.log("Table rendered");
  }
  renderTable() {
    const tableEl = this.containerEl.querySelector(".file-table");
    if (tableEl instanceof HTMLElement) {
      tableEl.empty();
      const startIndex = (this.currentPage - 1) * this.itemsPerPage;
      const endIndex = Math.min(startIndex + this.itemsPerPage, this.files.length);
      const filesToRender = this.files.slice(startIndex, endIndex);
      this.renderer.render(tableEl, filesToRender, this.groupByFolder);
    }
  }
  applyFiltersAndSort() {
    this.filteredFiles = this.filter.applyFilters(
      this.files,
      this.currentFolder,
      Array.from(this.folderManager.getSelectedFolders())
      // Преобразуем Set в массив
    );
    const activeBookmark = this.bookmarks.getActiveBookmark();
    if (activeBookmark) {
      this.filteredFiles = this.filteredFiles.filter(
        (file) => file.folder.toLowerCase().includes(activeBookmark.toLowerCase())
      );
    }
    this.filteredFiles = this.sorter.sortFiles(this.filteredFiles);
    this.paginationManager.updateTotalPages(this.filteredFiles.length);
  }
  updateTableContent() {
    this.applyFiltersAndSort();
    this.render();
  }
  updateFileTable(files, groupByFolder) {
    console.log(`Updating file table: ${files.length} files, groupByFolder: ${groupByFolder}`);
    this.files = files;
    this.groupByFolder = groupByFolder;
    this.applyFiltersAndSort();
    this.render();
  }
  areFilesEqual(files1, files2) {
    if (files1.length !== files2.length)
      return false;
    return files1.every(
      (file, index) => file.path === files2[index].path && file.modifiedAt.getTime() === files2[index].modifiedAt.getTime()
    );
  }
  // Геттеры и сеттеры
  getFilteredFiles() {
    return this.filteredFiles;
  }
  getGroupByFolder() {
    return this.groupByFolder;
  }
  getCurrentFolder() {
    return this.currentFolder;
  }
  getSorter() {
    return this.sorter;
  }
  getFilter() {
    return this.filter;
  }
  getPlugin() {
    return this.plugin;
  }
  getFolderManager() {
    return this.folderManager;
  }
  getPaginationManager() {
    return this.paginationManager;
  }
  getSessionManager() {
    return this.sessionManager;
  }
  getColumnResizer() {
    return this.columnResizer;
  }
  setCurrentFolder(folder) {
    this.currentFolder = folder;
  }
  saveTableState() {
    this.sessionManager.saveSession();
    this.plugin.settings.bookmarks = this.bookmarks.getBookmarks();
    this.plugin.saveSettings();
  }
  updatePagination() {
    const paginationEl = this.containerEl.querySelector(".pagination");
    if (paginationEl) {
      paginationEl.empty();
      paginationEl.createSpan({
        text: `\u0421\u0442\u0440\u0430\u043D\u0438\u0446\u0430 ${this.currentPage} \u0438\u0437 ${this.totalPages}`
      });
      if (this.totalPages > 1) {
        paginationEl.createEl("button", {
          text: "\u041F\u0440\u0435\u0434\u044B\u0434\u0443\u0449\u0430\u044F",
          cls: "pagination-button",
          attr: { disabled: this.currentPage === 1 }
        }).addEventListener("click", () => this.goToPage(this.currentPage - 1));
        paginationEl.createEl("button", {
          text: "\u0421\u043B\u0435\u0434\u0443\u044E\u0449\u0430\u044F",
          cls: "pagination-button",
          attr: { disabled: this.currentPage === this.totalPages }
        }).addEventListener("click", () => this.goToPage(this.currentPage + 1));
      }
    }
  }
  goToPage(page) {
    if (page >= 1 && page <= this.totalPages) {
      this.currentPage = page;
      this.renderTable();
      this.updatePagination();
    }
  }
  getAllFolders() {
    return Array.from(new Set(this.files.map((file) => file.folder)));
  }
  setFilteredFolders(folders) {
    this.filteredFiles = this.files.filter((file) => folders.includes(file.folder));
    this.applyFiltersAndSort();
    this.paginationManager.resetCurrentPage();
    this.render();
  }
  getBookmarks() {
    return this.bookmarks;
  }
  getContainerEl() {
    return this.containerEl;
  }
};

// src/ui/SettingsTab.ts
var import_obsidian8 = require("obsidian");
var SettingsTab = class extends import_obsidian8.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 File Table Plugin" });
    containerEl.createEl("h3", { text: "\u041E\u0441\u043D\u043E\u0432\u043D\u044B\u0435 \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438" });
    new import_obsidian8.Setting(containerEl).setName("\u0420\u0430\u0441\u0448\u0438\u0440\u0435\u043D\u0438\u044F \u0444\u0430\u0439\u043B\u043E\u0432").setDesc("\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0440\u0430\u0441\u0448\u0438\u0440\u0435\u043D\u0438\u044F \u0444\u0430\u0439\u043B\u043E\u0432 \u0447\u0435\u0440\u0435\u0437 \u0437\u0430\u043F\u044F\u0442\u0443\u044E (\u043D\u0430\u043F\u0440\u0438\u043C\u0435\u0440: pdf,cdr,eps)").addText((text) => text.setPlaceholder("pdf,cdr,eps").setValue(this.plugin.settings.fileExtensions.join(",")).onChange(async (value) => {
      this.plugin.settings.fileExtensions = value.split(",").map((ext) => ext.trim());
      await this.plugin.saveSettings();
    }));
    new import_obsidian8.Setting(containerEl).setName("\u0413\u0440\u0443\u043F\u043F\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u043F\u043E \u043F\u0430\u043F\u043A\u0430\u043C").setDesc("\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u0433\u0440\u0443\u043F\u043F\u0438\u0440\u043E\u0432\u043A\u0443 \u0444\u0430\u0439\u043B\u043E\u0432 \u043F\u043E \u043F\u0430\u043F\u043A\u0430\u043C").addToggle((toggle) => toggle.setValue(this.plugin.settings.groupByFolder).onChange(async (value) => {
      this.plugin.settings.groupByFolder = value;
      await this.plugin.saveSettings();
      await this.plugin.updateFileTable();
    }));
    containerEl.createEl("h3", { text: "\u041E\u0442\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0435" });
    new import_obsidian8.Setting(containerEl).setName("\u041C\u0435\u0441\u0442\u043E \u043E\u0442\u043A\u0440\u044B\u0442\u0438\u044F").setDesc("\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435, \u0433\u0434\u0435 \u043E\u0442\u043A\u0440\u044B\u0432\u0430\u0442\u044C \u0442\u0430\u0431\u043B\u0438\u0446\u0443 \u0444\u0430\u0439\u043B\u043E\u0432").addDropdown((dropdown) => dropdown.addOption("left", "\u0421\u043B\u0435\u0432\u0430").addOption("right", "\u0421\u043F\u0440\u0430\u0432\u0430").addOption("main", "\u0412 \u0433\u043B\u0430\u0432\u043D\u043E\u043C \u043E\u043A\u043D\u0435").setValue(this.plugin.settings.openLocation).onChange(async (value) => {
      this.plugin.settings.openLocation = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian8.Setting(containerEl).setName("CSS \u0444\u0430\u0439\u043B").setDesc("\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 CSS \u0444\u0430\u0439\u043B \u0434\u043B\u044F \u0441\u0442\u0438\u043B\u0438\u0437\u0430\u0446\u0438\u0438 \u0442\u0430\u0431\u043B\u0438\u0446\u044B \u0444\u0430\u0439\u043B\u043E\u0432").addDropdown(async (dropdown) => {
      const cssFiles = await this.getCSSFiles();
      cssFiles.forEach((file) => {
        dropdown.addOption(file, file);
      });
      dropdown.setValue(this.plugin.settings.cssFile);
      dropdown.onChange(async (value) => {
        this.plugin.settings.cssFile = value;
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h3", { text: "\u0423\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u0438\u0435 \u043F\u0430\u043F\u043A\u0430\u043C\u0438" });
    this.renderFolderSection(
      "\u0421\u043A\u0430\u043D\u0438\u0440\u0443\u0435\u043C\u044B\u0435 \u043F\u0430\u043F\u043A\u0438",
      this.plugin.settings.scannedFolders,
      (folder) => this.plugin.addScannedFolder(folder),
      (folder) => this.plugin.removeScannedFolder(folder)
    );
    this.renderFolderSection(
      "\u0418\u0433\u043D\u043E\u0440\u0438\u0440\u0443\u0435\u043C\u044B\u0435 \u043F\u0430\u043F\u043A\u0438",
      this.plugin.settings.ignoredFolders,
      (folder) => this.plugin.addIgnoredFolder(folder),
      (folder) => this.plugin.removeIgnoredFolder(folder)
    );
    new import_obsidian8.Setting(containerEl).setName("\u0421\u043E\u0445\u0440\u0430\u043D\u044F\u0442\u044C \u043F\u0430\u043F\u043A\u0438 \u043C\u0435\u0436\u0434\u0443 \u0441\u0435\u0441\u0441\u0438\u044F\u043C\u0438").setDesc("\u0415\u0441\u043B\u0438 \u0432\u043A\u043B\u044E\u0447\u0435\u043D\u043E, \u0432\u044B\u0431\u0440\u0430\u043D\u043D\u044B\u0435 \u043F\u0430\u043F\u043A\u0438 \u0431\u0443\u0434\u0443\u0442 \u0441\u043E\u0445\u0440\u0430\u043D\u044F\u0442\u044C\u0441\u044F \u043C\u0435\u0436\u0434\u0443 \u0441\u0435\u0441\u0441\u0438\u044F\u043C\u0438").addToggle((toggle) => toggle.setValue(this.plugin.settings.saveFoldersBetweenSessions).onChange(async (value) => {
      this.plugin.settings.saveFoldersBetweenSessions = value;
      await this.plugin.saveSettings();
      this.display();
    }));
  }
  renderFolderSection(title, folders, addCallback, removeCallback) {
    const sectionEl = this.containerEl.createEl("div", { cls: "folder-section" });
    new import_obsidian8.Setting(sectionEl).setName(title).setDesc(`\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u043F\u0430\u043F\u043A\u0438 \u0434\u043B\u044F ${title.toLowerCase()}`).addButton((button) => button.setButtonText("\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u043F\u0430\u043F\u043A\u0443").onClick(async () => {
      new FolderSuggestModal2(this.app, async (folder) => {
        await addCallback(folder);
        await this.plugin.saveSettings();
        await this.plugin.updateFileTable();
        this.display();
      }).open();
    }));
    folders.forEach((folder) => {
      new import_obsidian8.Setting(sectionEl).setName(folder || "\u041A\u043E\u0440\u043D\u0435\u0432\u0430\u044F \u043F\u0430\u043F\u043A\u0430").addButton((button) => button.setIcon("trash").setTooltip(`\u0423\u0434\u0430\u043B\u0438\u0442\u044C \u0438\u0437 ${title.toLowerCase()}`).onClick(async () => {
        await removeCallback(folder);
        await this.plugin.saveSettings();
        await this.plugin.updateFileTable();
        this.display();
      }));
    });
  }
  async getCSSFiles() {
    const cssFiles = [];
    const pluginDir = (0, import_obsidian8.normalizePath)(this.app.vault.configDir + "/plugins/file-table-plugin");
    try {
      const pluginFiles = await this.app.vault.adapter.list(pluginDir);
      pluginFiles.files.filter((file) => file.endsWith(".css")).forEach((file) => cssFiles.push((0, import_obsidian8.normalizePath)(file)));
    } catch (error) {
      console.error("Failed to read plugin directory:", error);
    }
    cssFiles.push("styles.css");
    cssFiles.push("altstyles.css");
    const uniqueCssFiles = Array.from(new Set(cssFiles)).sort();
    console.log("Available CSS files:", uniqueCssFiles);
    return uniqueCssFiles;
  }
};
var FolderSuggestModal2 = class extends import_obsidian8.FuzzySuggestModal {
  constructor(app, selectFolder) {
    super(app);
    this.selectFolder = selectFolder;
  }
  getItems() {
    return ["", ...this.getAllFolderPaths()];
  }
  getItemText(item) {
    return item || "\u041A\u043E\u0440\u043D\u0435\u0432\u0430\u044F \u043F\u0430\u043F\u043A\u0430";
  }
  onChooseItem(item, evt) {
    this.selectFolder(item);
  }
  renderSuggestion(item, el) {
    el.setText(this.getItemText(item.item));
  }
  getAllFolderPaths() {
    const folders = [];
    const stack = [this.app.vault.getRoot()];
    while (stack.length > 0) {
      const currentFolder = stack.pop();
      folders.push(currentFolder.path);
      currentFolder.children.filter((child) => child instanceof import_obsidian8.TFolder).forEach((childFolder) => stack.push(childFolder));
    }
    return folders;
  }
};

// src/FileTablePlugin.ts
var DEFAULT_SETTINGS = {
  fileExtensions: ["pdf", "cdr", "eps"],
  groupByFolder: false,
  openLocation: "right",
  cssFile: "styles.css",
  scannedFolders: [],
  ignoredFolders: [],
  saveFoldersBetweenSessions: true,
  bookmarks: []
};
var FILE_TABLE_VIEW_TYPE = "file-table-view";
var FileTablePlugin = class extends import_obsidian9.Plugin {
  constructor() {
    super(...arguments);
    this.currentStyleElement = null;
    // Добавляем метод для отложенного обновления таблицы
    this.debouncedUpdateFileTable = debounce(() => this.updateFileTable(), 1e3, true);
  }
  async onload() {
    console.log("Loading File Table Plugin");
    await this.loadSettings();
    this.fileService = new FileService(this.app.vault, this.app);
    this.folderService = new FolderService(this.app.vault);
    this.addSettingTab(new SettingsTab(this.app, this));
    this.registerView(FILE_TABLE_VIEW_TYPE, (leaf) => {
      this.fileTableView = new FileTableView(leaf, this);
      return this.fileTableView;
    });
    this.addRibbonIcon("table", "Open File Table", () => {
      this.activateView();
    });
    this.app.workspace.onLayoutReady(async () => {
      console.log("Layout ready, activating view");
      await this.activateView();
      await this.updateFileTable();
    });
    this.registerEvent(this.app.vault.on("create", this.debouncedUpdateFileTable.bind(this)));
    this.registerEvent(this.app.vault.on("delete", this.debouncedUpdateFileTable.bind(this)));
    this.registerEvent(this.app.vault.on("rename", this.debouncedUpdateFileTable.bind(this)));
    this.registerEvent(this.app.vault.on("modify", this.debouncedUpdateFileTable.bind(this)));
    await this.loadSelectedCSS();
    this.registerEvent(this.app.workspace.on("quit", this.onQuit.bind(this)));
    this.addCommand({
      id: "add-folder-to-file-table",
      name: "\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u043F\u0430\u043F\u043A\u0443 \u0432 \u0442\u0430\u0431\u043B\u0438\u0446\u0443 \u0444\u0430\u0439\u043B\u043E\u0432",
      callback: () => {
        new FolderSuggestModal(this.app, async (folder) => {
          await this.addScannedFolder(folder);
          if (this.fileTableView) {
            this.fileTableView.updateFileTable();
          }
        }).open();
      }
    });
    this.addCommand({
      id: "add-folder-to-ignored",
      name: "\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u043F\u0430\u043F\u043A\u0443 \u0432 \u0438\u0433\u043D\u043E\u0440\u0438\u0440\u0443\u0435\u043C\u044B\u0435",
      hotkeys: [{ modifiers: ["Ctrl", "Shift"], key: "I" }],
      callback: () => {
        new FolderSuggestModal(this.app, async (folder) => {
          await this.addIgnoredFolder(folder);
          if (this.fileTableView) {
            this.fileTableView.updateFileTable();
          }
        }).open();
      }
    });
    this.addCommand({
      id: "clear-file-table",
      name: "\u041E\u0447\u0438\u0441\u0442\u0438\u0442\u044C \u0442\u0430\u0431\u043B\u0438\u0446\u0443 \u0444\u0430\u0439\u043B\u043E\u0432",
      hotkeys: [{ modifiers: ["Ctrl", "Shift"], key: "C" }],
      callback: async () => {
        await this.clearFolders();
        if (this.fileTableView) {
          this.fileTableView.updateFileTable();
        }
      }
    });
    this.addCommand({
      id: "clear-bookmarks",
      name: "\u041E\u0447\u0438\u0441\u0442\u0438\u0442\u044C \u0432\u0441\u0435 \u0437\u0430\u043A\u043B\u0430\u0434\u043A\u0438",
      callback: () => {
        this.settings.bookmarks = [];
        this.saveSettings();
        if (this.fileTableView) {
          this.fileTableView.getFileTable().getBookmarks().setBookmarks([]);
          this.fileTableView.updateFileTable();
        }
      }
    });
  }
  async updateFileTable() {
    console.log("Updating file table");
    const files = await this.getAllFilesInScannedFolders();
    console.log(`Found ${files.length} files in scanned folders:`, this.settings.scannedFolders);
    if (this.fileTableView) {
      await this.fileTableView.updateFileTable(files, this.settings.groupByFolder);
    }
    console.log(`File table updated with ${files.length} files`);
  }
  async onQuit() {
    if (!this.settings.saveFoldersBetweenSessions) {
      this.settings.scannedFolders = [];
      this.settings.ignoredFolders = [];
    }
    await this.saveData(this.settings);
  }
  async loadSelectedCSS() {
    if (this.currentStyleElement) {
      this.currentStyleElement.remove();
    }
    let cssContent;
    try {
      const cssPath = (0, import_obsidian9.normalizePath)(this.manifest.dir + "/" + this.settings.cssFile);
      cssContent = await this.app.vault.adapter.read(cssPath);
    } catch (error) {
      console.error(`Failed to load CSS file: ${this.settings.cssFile}`, error);
      cssContent = await this.loadDefaultCSS();
    }
    this.currentStyleElement = document.createElement("style");
    this.currentStyleElement.textContent = cssContent;
    document.head.appendChild(this.currentStyleElement);
  }
  async loadDefaultCSS() {
    return `
      .file-table-container { /* Default styles */ }
      .file-table { /* Default styles */ }
      /* Add more default styles here */
    `;
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    await this.loadSelectedCSS();
    await this.updateFileTable();
  }
  async loadFiles() {
    const files = await this.getAllFilesInScannedFolders();
    if (this.fileTableView) {
      this.fileTableView.updateFileTable(files, this.settings.groupByFolder);
    }
  }
  async getAllFilesInScannedFolders() {
    if (this.settings.scannedFolders.length === 0) {
      return [];
    }
    const allFiles = [];
    for (const folder of this.settings.scannedFolders) {
      const files = await this.fileService.getFilesInFolder(folder, this.settings.fileExtensions);
      allFiles.push(...files);
    }
    return allFiles.filter(
      (file) => !this.settings.ignoredFolders.some(
        (ignoredFolder) => file.folder === ignoredFolder || file.folder.startsWith(ignoredFolder + "/")
      )
    );
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(FILE_TABLE_VIEW_TYPE);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getLeaf(false);
      await leaf.setViewState({ type: FILE_TABLE_VIEW_TYPE, active: true });
    }
    workspace.revealLeaf(leaf);
  }
  // Публичные методы для доступа к функциональности fileService
  async getFilesInFolder(folderPath, extensions) {
    return this.fileService.getFilesInFolder(folderPath, extensions);
  }
  openFile(path) {
    this.fileService.openFile(path);
  }
  openSettingTab() {
    const settingTab = new SettingsTab(this.app, this);
    this.app.workspace.getLeaf().setViewState({
      type: "empty",
      active: true
    }).then(() => {
      var _a;
      this.app.workspace.revealLeaf(
        this.app.workspace.getLeavesOfType("empty")[0]
      );
      (_a = this.app.workspace.getActiveViewOfType(import_obsidian9.ItemView)) == null ? void 0 : _a.leaf.setViewState({
        type: "empty",
        state: { settingTab }
      });
    });
  }
  // Добавьте этот публичный метод
  getFolderManager() {
    var _a;
    return (_a = this.fileTableView) == null ? void 0 : _a.getFolderManager();
  }
  // Добавьте этот новый публичный метод
  async clearFolders() {
    this.settings.scannedFolders = [];
    this.settings.ignoredFolders = [];
    if (this.fileTableView) {
      this.fileTableView.clearFolders();
    }
    await this.saveSettings();
    await this.updateFileTable();
  }
  // Добавляем метод onunload
  async onunload() {
    console.log("Unloading File Table Plugin");
    await this.saveSettings();
  }
  // Обновляем метод addScannedFolder
  async addScannedFolder(folder) {
    if (!this.settings.scannedFolders.includes(folder)) {
      this.settings.scannedFolders.push(folder);
      await this.saveSettings();
    }
    if (this.fileTableView) {
      const folderManager = this.fileTableView.getFolderManager();
      if (folderManager) {
        await folderManager.addFolder(folder);
        await this.updateFileTable();
      }
    }
  }
  async removeScannedFolder(folder) {
    var _a, _b;
    this.settings.scannedFolders = this.settings.scannedFolders.filter((f) => f !== folder);
    await this.saveSettings();
    (_b = (_a = this.fileTableView) == null ? void 0 : _a.getFolderManager()) == null ? void 0 : _b.removeFolder(folder);
    await this.updateFileTable();
  }
  async addIgnoredFolder(folder) {
    var _a, _b;
    if (!this.settings.ignoredFolders.includes(folder)) {
      this.settings.ignoredFolders.push(folder);
      await this.saveSettings();
    }
    (_b = (_a = this.fileTableView) == null ? void 0 : _a.getFolderManager()) == null ? void 0 : _b.addIgnoredFolder(folder);
    await this.updateFileTable();
  }
  async removeIgnoredFolder(folder) {
    var _a, _b;
    this.settings.ignoredFolders = this.settings.ignoredFolders.filter((f) => f !== folder);
    await this.saveSettings();
    (_b = (_a = this.fileTableView) == null ? void 0 : _a.getFolderManager()) == null ? void 0 : _b.removeIgnoredFolder(folder);
    await this.updateFileTable();
  }
};
var FileTableView = class extends import_obsidian9.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
  }
  getViewType() {
    return FILE_TABLE_VIEW_TYPE;
  }
  getDisplayText() {
    return "File Table";
  }
  async onOpen() {
    this.fileTable = new FileTable(this.containerEl, (path) => this.plugin.openFile(path), this.plugin);
    this.fileTable.getBookmarks().setBookmarks(this.plugin.settings.bookmarks);
    await this.updateFileTable();
    console.log("FileTable initialized:", this.fileTable);
  }
  async onClose() {
  }
  async updateFileTable(files, groupByFolder) {
    if (!files) {
      files = await this.plugin.getAllFilesInScannedFolders();
    }
    if (groupByFolder === void 0) {
      groupByFolder = this.plugin.settings.groupByFolder;
    }
    this.fileTable.updateFileTable(files, groupByFolder);
    console.log(`Updating file table with ${files.length} files, groupByFolder: ${groupByFolder}`);
  }
  // Добавьте этот метод
  getFolderManager() {
    var _a;
    return (_a = this.fileTable) == null ? void 0 : _a.getFolderManager();
  }
  clearFolders() {
    this.fileTable.getFolderManager().setSelectedFolders([]);
    this.fileTable.setCurrentFolder("");
  }
  getFileTable() {
    return this.fileTable;
  }
};
function debounce(func, wait, immediate) {
  let timeout;
  return function() {
    const context = this, args = arguments;
    const later = function() {
      timeout = null;
      if (!immediate)
        func.apply(context, args);
    };
    const callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow)
      func.apply(context, args);
  };
}

// src/main.ts
var MainPlugin = class extends import_obsidian10.Plugin {
  async onload() {
    this.fileTablePlugin = new FileTablePlugin(this.app, this.manifest);
    await this.fileTablePlugin.onload();
  }
  async onunload() {
    await this.fileTablePlugin.onunload();
  }
};
